import axios, { AxiosRequestConfig, AxiosInterceptorManager, AxiosResponse, AxiosPromise } from 'axios'

/**
 * Key-Value object type.
 */
export interface KVO<T = any> {
  [key: string]: T
}

/**
 * XhrRef xhr reference, used to abort/force retrying, etc...
 */
export type XhrRef =
  | undefined
  | {
      abort(options?: { ignoreRetry: boolean }): void // abort the request
      retryImmediately(): void // skip current retry waiting strategy and retry the request immediately
    }

/**
 * XHR Request.
 */
export interface XhrRequest {
  url?: string
  params?: KVO
  headers?: KVO
  data?: any
}

/**
 * XHR Response.
 */
export interface XhrResponse {
  status: number
  statusText: string
  data?: any
  headers?: KVO
  error?: any
  request: XhrRequest
}

export type XhrRetryStrategy = (params: { counter: number, lastStatus: number }) => number

/**
 * Request Options extends AxiosRequestConfig with xhr setter support.
 * @export
 * @interface RequestOptions
 * @extends {AxiosRequestConfig}
 */
export interface XhrOptions extends AxiosRequestConfig {
  ref?: (request: XhrRef) => void

  // xhr group, used to terminate a batch of xhr requests
  group?: string

  // retry if failed
  retry?: number | XhrRetryStrategy
}

/**
 * Before Interceptor.
 */
export type XhrBeforeInterceptor = (args: XhrRequest) => void

/**
 * After Interceptor.
 */
export type XhrAfterInterceptor = (args: XhrResponse) => void

const STOP_RETRYING = -1
const UNREACHABLE = 0
const ABORTED = -1
const TIMEOUT = -2

/**
 * Inject an interceptor before a request is being made.
 * @param interceptor interceptor.
 */
const xhrBefore = (interceptor: XhrBeforeInterceptor) => {
  axios.interceptors.request.use(
    (config: XhrOptions) => {
      const { url = '', params, headers, data } = config

      interceptor({ url, params, headers, data })

      return config
    },
    (error: any) => Promise.reject(error)
  )
}

/**
 * Inject an interceptor after a response is returned.
 * @param interceptor interceptor.
 */
const xhrAfter = (interceptor: XhrAfterInterceptor) => {
  axios.interceptors.response.use(
    (response: any) => {
      const { status, statusText, headers: responseHeaders, data: responseData, config } = response
      const { url, params, headers, data } = config

      interceptor({
        status,
        statusText,
        data: responseData,
        headers: responseHeaders,
        request: { url, params, data, headers }
      })

      return response
    },
    (error: any) => Promise.reject(error)
  )
}

//
// Xhr groups is used to store on-going requests.
//
const xhrGroups: KVO<KVO<XhrRef>> = {}

//
// On-going requests are stored in requests and will be cleaned up
// when they are finished
//
export interface RequestTrackingInfo {
  config: XhrOptions,
  status?: number,
  startTime: number
}
const requests: KVO<RequestTrackingInfo> = {}

//
// Unique auto-generated id for each request
//
let autoGeneratedId: number = 0

//
// Intercept axios request to inject cancel token, set/unset xhr, etc...
//
axios.interceptors.request.use(
  (config: XhrOptions) => {
    const { ref, group, retry } = config
    const id = (config as KVO).id as string

    // save options into requests for reference
    requests[id] = { config, startTime: +new Date() }

    if (ref || group) {
      config.cancelToken = new axios.CancelToken(cancel => {
        const requestRef: XhrRef = {
          abort: (options) => {
            cancel()

            const _id = (config as KVO).id as string // get latest id from config (it may be changed during retrying)

            if (ref) {
              ref(undefined) // unset xhr reference
            }

            if (group) {
              delete xhrGroups[group][id]
            }

            // Set request status if only the request's info in requests still exists.
            // In case of retry, this information is removed during setTimeout delay
            if (requests[_id]) {
              requests[_id].status = ABORTED
            }

            if (options && options.ignoreRetry) {
              const retryFn = typeof(retry) !== 'number' && retry as KVO

              if (retryFn) {
                retryFn.cancelRetry()
              }
            }
          },

          retryImmediately: () => {
            const retryFn = typeof(retry) !== 'number' && retry as KVO

            if (retryFn) {
              retryFn.forceRetry()
            }
          }
        }

        if (group) {
          xhrGroups[group] = xhrGroups[group] || {}
          xhrGroups[group][id] = requestRef
        }

        // call xhr so caller has a change to save the xhr object with abort()/retry() capability
        if (ref) {
          ref(requestRef)
        }
      })
    }

    return config
  },
  (error: any) => Promise.reject(error)
)

//
// Intercept axios response to unset xhr.
//
axios.interceptors.response.use(
  (response: any) => {
    const { ref, id, group } = response.config as XhrOptions & KVO

    // call ref() to pass undefined so caller has a chance to set its xhr reference to undefined
    if (ref) {
      ref(undefined)
    }

    if (group) {
      delete xhrGroups[group][id as string]

      if (!Object.keys(xhrGroups[group]).length) {
        delete xhrGroups[group]
      }
    }

    delete requests[id as string]

    return response
  },
  (error: any) => Promise.reject(error)
)

async function get(url: string, options: XhrOptions = {}): Promise<XhrResponse> {
  // add extra id property to track back to config when exception occurs
  (options as KVO).id = ++autoGeneratedId + '-' + (new Date()).toUTCString()
  options.url = url

  try {
    const { status, statusText, headers: responseHeaders, data: responseData, config } = await axios(options)
    const { params, data, headers } = config

    // Clean up retryFn if it exists
    const { retry } = options
    const retryFn = retry && typeof(retry) !== 'number' && (retry as KVO)

    if (retryFn) {
      delete retryFn.counter
      delete retryFn.forceRetry
    }

    return {
      status,
      statusText,
      data: responseData,
      headers: responseHeaders,
      request: { url, params, data, headers }
    }
  } catch (error) {
    const { response } = error
    const id = (options as KVO).id as string
    const request = requests[id]
    const { config } = request
    let status = (request.status || response && response.status) || UNREACHABLE

    // Determine if request is timeout
    if (status === UNREACHABLE && !!config.timeout) {
      const duration = +new Date() - request.startTime
      if (duration >= config.timeout) {
        status = TIMEOUT
      }
    }

    delete requests[id]

    const generateErrorResult = (optionalStatus?: number) => {
      const { ref } = options
      const { params = undefined, data = undefined, headers = {} } = config || {}

      if (ref) {
        ref(undefined) // unset xhr
      }

      return {
        status: optionalStatus || status,
        statusText: (response && response.statusText) || error.toString(),
        error,
        data: response && response.data,
        request: { url, params, data, headers }
      }
    }

    if (options.retry) {
      if (typeof(options.retry) === 'number' && options.retry > 0) {
        options.retry--
        return get(url, options)
      } else {
        // trick to add extra counter and timeoutId into retryFn
        const retryFn = (options.retry as XhrRetryStrategy & KVO)
        const { counter, timeoutId } = retryFn
        retryFn.counter = (counter || 0) + 1

        if (timeoutId) {
          clearTimeout(timeoutId)
        }

        const delay = retryFn({ counter: retryFn.counter, lastStatus: status })

        if (delay >= 0) {
          return new Promise<XhrResponse>(resolve => {
            retryFn.timeoutId = setTimeout(_ => {
              delete retryFn.timeoutId
              delete retryFn.forceRetry

              resolve(get(url, options))
            }, delay)

            retryFn.forceRetry = () => {
              clearTimeout(retryFn.timeoutId)
              delete retryFn.timeoutId
              resolve(get(url, options))
            }

            retryFn.cancelRetry = () => {
              clearTimeout(retryFn.timeoutId)
              delete retryFn.timeoutId
              delete retryFn.counter
              resolve(generateErrorResult(ABORTED))
            }
          })
        } else {
          delete retryFn.counter
          delete retryFn.forceRetry
        }
      }
    }

    return generateErrorResult()
  }
}

export function requestFor(method: string) {
  return async (url: string, options: XhrOptions = {}): Promise<XhrResponse> => {
    options.method = method
    return get(url, options)
  }
}

function abort(group: string) {
  const xhrGroup = xhrGroups[group]

  if (xhrGroup) {
    Object.keys(xhrGroup).forEach(id => {
      const request = xhrGroup[id]
      if (request) {
        request.abort()
      }
    })
    delete xhrGroups[group]
  }
}

const xhr = {
  get,
  post: requestFor('POST'),
  put: requestFor('PUT'),
  delete: requestFor('DELETE'),
  head: requestFor('HEAD'),
  connect: requestFor('CONNECT'),
  options: requestFor('OPTIONS'),
  trace: requestFor('TRACE'),
  patch: requestFor('PATCH'),

  abort,

  // @see https://github.com/mzabriskie/axios#global-axios-defaults
  defaults: axios.defaults,

  before: xhrBefore,
  after: xhrAfter,

  STOP_RETRYING,

  ABORTED,
  TIMEOUT,
  UNREACHABLE
}

// This constant is exported for testing purposes only and should
// never be used
export const __internal__ = {
  xhrGroups,
  requests
}

export default xhr

xhr.defaults.headers.common['User-Agent'] = 'xhr-async' // TODO Add version

//
// TODO:
//
// - More tests (binary, stream, etc). Could get from axios' tests
// - Write README
// - Calling abort() should also terminate retrying? Or abort({ skipRetry: true }) DONE
// - Make xhr's properties read-only
