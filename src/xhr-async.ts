import axios, { AxiosRequestConfig, AxiosInterceptorManager, AxiosResponse, AxiosPromise } from 'axios'

/**
 * Key-Value object type.
 */
export interface KVO<T = any> {
  [key: string]: T
}

/**
 * XhrRef xhr reference, used to abort/force retrying, etc...
 */
export interface XhrRef {
  abort(options?: { ignoreRetry: boolean }): void // abort the request
  retryImmediately(): void // skip current retry waiting strategy and retry the request immediately
}

/**
 * XHR Request.
 */
export interface XhrRequest {
  url?: string
  params?: KVO
  headers?: KVO
  data?: any
}

/**
 * XHR Response.
 */
export interface XhrResponse {
  status: number
  statusText: string
  data?: any
  headers?: KVO
  error?: any
  request: XhrRequest
}

/**
 * Retry after a delay. If the function returns non-positive number, retry will stop.
 */
export type XhrRetryAfter = (params: { counter: number, lastStatus: number }) => number

/**
 * Request Options extends AxiosRequestConfig with xhr setter support.
 * @export
 * @interface RequestOptions
 * @extends {AxiosRequestConfig}
 */
export interface XhrOptions extends AxiosRequestConfig {
  ref?: (request?: XhrRef) => void

  // xhr group, used to terminate a batch of xhr requests
  group?: string

  // retry if failed
  retry?: number | XhrRetryAfter
}

/**
 * Before Interceptor.
 */
export type XhrBeforeInterceptor = (args: XhrRequest) => void

/**
 * After Interceptor.
 */
export type XhrAfterInterceptor = (args: XhrResponse) => void

/**
 * Inject an interceptor before a request is being made.
 * @param interceptor interceptor.
 */
const xhrBefore = (interceptor: XhrBeforeInterceptor) => {
  axios.interceptors.request.use(
    (config: XhrOptions) => {
      const { url = '', params, headers, data } = config

      interceptor({ url, params, headers, data })

      return config
    },
    (error: any) => Promise.reject(error)
  )
}

/**
 * Inject an interceptor after a response is returned.
 * @param interceptor interceptor.
 */
const xhrAfter = (interceptor: XhrAfterInterceptor) => {
  axios.interceptors.response.use(
    (response: any) => {
      const { status, statusText, headers: responseHeaders, data: responseData, config } = response
      const { url, params, headers, data } = config

      interceptor({
        status,
        statusText,
        data: responseData,
        headers: responseHeaders,
        request: { url, params, data, headers }
      })

      return response
    },
    (error: any) => Promise.reject(error)
  )
}

//
// Xhr groups is used to store on-going requests.
//
const xhrGroups: KVO<KVO<XhrRef>> = {}

//
// On-going requests are stored in requests and will be cleaned up
// when they are finished
//
export interface RequestTrackingInfo {
  config: XhrOptions,
  status?: number,
  startTime: number
}

//
// requests maintains information of all on-going requests
//
const requests: KVO<RequestTrackingInfo> = {}

//
// Unique auto-generated id for each request
//
let autoGeneratedId: number = 0

//
// Status constants
//
const UNREACHABLE =  0
const ABORTED     = -1
const TIMEOUT     = -2

//
// Intercept axios request to inject cancel token, set/unset xhr, etc...
//
axios.interceptors.request.use(
  (config: XhrOptions) => {
    const { ref, group, retry } = config
    const id = (config as KVO).id as string

    // save options into requests for reference
    requests[id] = { config, startTime: +new Date() }

    if (ref || group) {
      config.cancelToken = new axios.CancelToken(cancel => {
        const requestRef: XhrRef = {
          abort: options => {
            cancel()

            const _id = (config as KVO).id as string // get latest id from config (it may be changed during retrying)

            if (ref) {
              ref(undefined) // unset xhr reference
            }

            if (group) {
              delete xhrGroups[group][id]
            }

            // Set request status if only the request's info in requests still exists.
            // In case of retry, this information is removed during setTimeout delay
            if (requests[_id]) {
              requests[_id].status = ABORTED
            }

            if (options && options.ignoreRetry) {
              const retryAfter = typeof(retry) !== 'number' && retry as KVO

              if (retryAfter) {
                retryAfter.cancelRetry()
              }
            }
          },

          retryImmediately: () => {
            const retryAfter = typeof(retry) !== 'number' && retry as KVO

            if (retryAfter) {
              retryAfter.retryImmediately()
            }
          }
        }

        if (group) {
          xhrGroups[group] = xhrGroups[group] || {}
          xhrGroups[group][id] = requestRef
        }

        // call xhr so caller has a change to save the xhr object with abort()/retry() capability
        if (ref) {
          ref(requestRef)
        }
      })
    }

    return config
  },
  (error: any) => Promise.reject(error)
)

//
// Intercept axios response to unset xhr.
//
axios.interceptors.response.use(
  (response: any) => {
    const { ref, id, group } = response.config as XhrOptions & KVO

    // call ref() to pass undefined so caller has a chance to set its xhr reference to undefined
    if (ref) {
      ref(undefined)
    }

    if (group) {
      delete xhrGroups[group][id as string]

      if (!Object.keys(xhrGroups[group]).length) {
        delete xhrGroups[group]
      }
    }

    delete requests[id as string]

    return response
  },
  (error: any) => Promise.reject(error)
)

async function get(url: string, options: XhrOptions = {}): Promise<XhrResponse> {
  // add extra id property to track back to config when exception occurs
  (options as KVO).id = ++autoGeneratedId + '-' + (new Date()).toUTCString()
  options.url = url

  try {
    const { status, statusText, headers: responseHeaders, data: responseData, config } = await axios(options)
    const { params, data, headers } = config

    // Clean up retryAfter if it exists
    const { retry } = options
    const retryAfter = retry && typeof(retry) !== 'number' && (retry as KVO)

    if (retryAfter) {
      delete retryAfter.counter
      delete retryAfter.retryImmediately
    }

    return {
      status,
      statusText,
      data: responseData,
      headers: responseHeaders,
      request: { url, params, data, headers }
    }
  } catch (error) {
    const { response } = error
    const id = (options as KVO).id as string
    const request = requests[id]
    const { config } = request
    let status = (request.status || response && response.status) || UNREACHABLE

    // Determine if request is timeout
    if (status === UNREACHABLE && !!config.timeout) {
      const duration = +new Date() - request.startTime
      if (duration >= config.timeout) {
        status = TIMEOUT
      }
    }

    delete requests[id]

    const generateErrorResult = (optionalStatus?: number) => {
      const { ref } = options
      const { params = undefined, data = undefined, headers = {} } = config || {}

      if (ref) {
        ref(undefined) // unset xhr
      }

      return {
        status: optionalStatus || status,
        statusText: (response && response.statusText) || error.toString(),
        error,
        data: response && response.data,
        request: { url, params, data, headers }
      }
    }

    if (options.retry) {
      if (typeof(options.retry) === 'number' && options.retry > 0) {
        options.retry--
        return get(url, options)
      } else {
        // trick to add extra counter and timeoutId into retryAfter
        const retryAfter = (options.retry as XhrRetryAfter & KVO)
        const { counter, timeoutId } = retryAfter
        retryAfter.counter = (counter || 0) + 1

        if (timeoutId) {
          clearTimeout(timeoutId)
        }

        const delay = retryAfter({ counter: retryAfter.counter, lastStatus: status })
        const cleanup = (skipCounter: boolean = false) => {
          delete retryAfter.timeoutId
          if (!skipCounter) {
            delete retryAfter.counter
          }
          delete retryAfter.retryImmediately
          delete retryAfter.cancelRetry
        }

        if (delay >= 0) {
          return new Promise<XhrResponse>(resolve => {
            retryAfter.timeoutId = setTimeout(() => {
              resolve(get(url, options))
              cleanup(true)
            }, delay)

            retryAfter.retryImmediately = () => {
              clearTimeout(retryAfter.timeoutId)
              resolve(get(url, options))
              cleanup(true)
            }

            retryAfter.cancelRetry = () => {
              clearTimeout(retryAfter.timeoutId)
              cleanup()
              resolve(generateErrorResult(ABORTED))
            }
          })
        } else {
          cleanup()
        }
      }
    }

    return generateErrorResult()
  }
}

export function requestFor(method: string) {
  return async (url: string, options: XhrOptions = {}): Promise<XhrResponse> => {
    options.method = method
    return get(url, options)
  }
}

function abort(group: string) {
  const xhrGroup = xhrGroups[group]

  if (xhrGroup) {
    Object.keys(xhrGroup).forEach(id => {
      const request = xhrGroup[id]
      if (request) {
        request.abort()
      }
    })
    delete xhrGroups[group]
  }
}

const xhr = {
  get,
  post: requestFor('POST'),
  put: requestFor('PUT'),
  delete: requestFor('DELETE'),
  head: requestFor('HEAD'),
  connect: requestFor('CONNECT'),
  options: requestFor('OPTIONS'),
  trace: requestFor('TRACE'),
  patch: requestFor('PATCH'),

  abort,

  // @see https://github.com/mzabriskie/axios#global-axios-defaults
  defaults: axios.defaults,

  before: xhrBefore,
  after: xhrAfter,

  ABORTED,
  TIMEOUT,
  UNREACHABLE
}

//
// Make xhr readonly at runtime
//
Object.keys(xhr).forEach(key =>
  Object.defineProperty(xhr, key, {
    value: (xhr as KVO)[key],
    writable: false,
    configurable: false,
    enumerable: true
  })
)

// This constant is exported for testing purposes only
// export const __internal__ = { xhrGroups, requests }

xhr.defaults.headers.common['User-Agent'] = 'xhr-async' // TODO Add version at build time

export default xhr

//
// TODO:
//
// - More tests (binary, stream, etc). Could get from axios' tests
// - Write README
